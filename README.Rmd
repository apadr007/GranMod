---
title: "README"
author: "Alex Padron"
date: "October 16, 2016"
output: html_document
---

# An example of how to run the granule model scripts

- The granule model is a function that takes a number of parameters. 
- The number of nodes (node_number) represents the number of mRNAs to begin with. We'll set it to 25. 
- SpaceMax will symmetrically define the space we'll use to for each simulation.
- A randomly placed empty graph, g.
- Total_time starting at 1 in this case.
- final_time to stop simulation at.
- Probability of two mRNPs binding, P.int.on.


```{r}
install.packages('igraph')
library(igraph)
#if you don't have the following packages installed, install it like this and then load them into your R session using the library function.

#install.packages('Rcpp')
#install.packages('RcppArmadillo')
#install.packages('inline')

#library(Rcpp)
#library(RcppArmadillo)
#library(inline)

setwd('~/GranMod/')
load.functions <- list.files('./granule-functions', full.names = TRUE)

#load all of the required functions
sapply(load.functions, source)
# note, the Rcpp package will produce a bunch of output when it's loaded that can be ignored for our purposes. 

set.seed(2014)
node_number = 40
spaceMax = 10

g=graph.empty(node_number,directed = FALSE)
valency = c(1,2,3,4,5,6)
total_time = 1
V(g)$color = 'lightblue'
# prob of binding two mRNP nearby
P.int.on = 0.6 
# prob of breaking a bond is automatically defined as the following, but can be set independent of P.int.on, which is probably a better idea. 
P.int.off = 1-P.int.on 

#layoutGen generates randomly positioned mRNAs
layout.old = layoutGen(node_number, spaceMax)
names = 1:node_number
layout.old = layout.old[[1]][,1:2]

total_time = 1
final_time = 10
mRNP_pop = list()
mRNA_pop = list()
output <- granule.model(node_number, spaceMax, g, total_time, final_time, P.int.on)

```
- mRNAs are defined as edge-less nodes (light blue)
- mRNPs are defined as nodes with more than 1 node (orange)
- granules are defined as interacting densely connected regions of interacting mRNPs

The output is a list with 3 outputs--two lists and output graph, which you can access the following way. In R, different data types can be placed inside a list and lists can be placed inside lists. 
```{r}
mRNP <- output[[1]]
mRNA <- output[[2]]

val.RNP <- (c(0,unlist(lapply(mRNP, length))))
val.mRNA <- c(node_number,unlist(lapply(mRNA, length)))

#plot mRNP over time
par(mfrow=c(2,2))
plot(val.RNP/max(val.RNP), cex=0.5, pch=19, col='blue', 
     ylab=c('Fraction of Dimers'), xlab=c('Timestep'))
#plot mRNAs over time
plot(val.mRNA/max(val.mRNA),cex=0.5, pch=19, col='red', 
     ylab=c('Fraction of of mRNA'), xlab=c('Timestep') )

```

#Alternatively, you can run the granule model script directly so as to access aspects of the code more easily.
```{r}
set.seed(2014)
node_number = 40
spaceMax = 10

g=graph.empty(node_number,directed = FALSE)
valency = c(1,2,3,4,5,6)
total_time = 1
V(g)$color = 'lightblue'
P.int.on = 0.6

layout.old = layoutGen(node_number, spaceMax)
names = 1:node_number
layout.old = layout.old[[1]][,1:2]

plot(g, layout = layout.old,vertex.label='',
     rescale = F, axes=TRUE, xlim=c(0,spaceMax), ylim=c(0,spaceMax), asp = 0 )

mRNP_pop = list()
mRNA_pop = list()
gran_pop = list()

total_time = 1
while(total_time <= 10){ 
  mRNA = 1:node_number 
  mRNA = which(!mRNA%in%which(degree(g) > 6)) 
  #move every node 
  layout.old = nodeMover7d(layout.old, g, node_number, spaceMax)
   #find the nearest nodes to every other node
  nearest.mRNA2 = findNearestMovers4(layout.old) # this finds the nearest nodes to every other node
  
  nearest.mRNA3 = cleaner.valency2(nearest.mRNA2, P.int.on)
  #delete an edge if its a neighbor BUT not found in findNearestMovers4
  g <- edgeRemoverSpace(g, layout.old ) 
  
  for (m in 1:length(mRNA)) {    
    if ( isTRUE(nearest.mRNA3[[m]] != 0) || !isEmpty(nearest.mRNA3[[m]])) {
       ### this adds edges
      for (j in 1:length(nearest.mRNA3[[m]])) {                                         
        
        if (isEmpty(nearest.mRNA3[[m]]) == FALSE && isTRUE(degree(g)[nearest.mRNA3[[m]][j]] < 6) ) {  
          g = add.edges(g, c(mRNA[m], nearest.mRNA3[[m]][j])) } 
      }
    } else { next }
  }
  #do not allow self edges
  g = simplify(g, remove.loops = TRUE)
  E(g)$color = 'black'
  
  del.index = which(degree(g) > 8) 
  if (isEmpty(del.index) == FALSE){
    for(k in 1:length(del.index)){
      g = del_edge(g, valToDel = del.index[k])
    }
  }
  #change color if node has edges
  colorme = which(degree(g) >= 1)
  staysamecolor = which(degree(g) < 1)
  if (isEmpty(colorme) == FALSE){
    for (i in 1:length(colorme)){
      x = colorme[i]
      V(g)$color[x] = 'orange'
    }
  }
  
  
  if (isEmpty(staysamecolor) == FALSE){
    for (i in 1:length(staysamecolor)){
      x = staysamecolor[i]
      V(g)$color[x] = 'lightblue'
    }
  }
  
  plot(g, layout = layout.old,vertex.label='',
     rescale = F, axes=TRUE, xlim=c(0,spaceMax), ylim=c(0,spaceMax), asp = 0 )
  
  mRNP_pop[[total_time]] = which(degree(g) >= 1)
  mRNA_pop[[total_time]] = which(degree(g) < 1)
  total_time = total_time + 1  
  print(total_time)
}
```

To find densely connected regions you can use the walktrap algorithm or something equivalent 
```{r}

colorme = which(degree(g) >= 1)
for (i in 1:length(colorme)){
  x = colorme[i]
  V(g)$color[x] = 'orange'
}

plot(g, layout = layout.old,vertex.label='',
     rescale = F, axes=TRUE, xlim=c(0,spaceMax), ylim=c(0,spaceMax), asp = 0 )
mRNA.return = length(which(V(g)$color == 'lightblue'))
g = delete.vertices(g, which(V(g)$color == 'lightblue'))
###walktrap 
fg= walktrap.community(g, modularity = TRUE, membership = TRUE)
V(g)$size = 1
E(g)$count = 1
comm.graph <- contract.vertices(g, fg$membership, vertex.attr.comb=list(size="sum", "ignore"))
comm.graph <- simplify(comm.graph, remove.loops=TRUE, edge.attr.comb=list(count="sum", "ignore"))
which(vertex.attributes(comm.graph)$size>=1)

for(i in 1:length(which(vertex.attributes(comm.graph)$size >= 1)) ){
  V(comm.graph)$color[i] = 'orange' 
}
E(comm.graph)$color = 'white'
comm.graph = add.vertices(comm.graph, mRNA.return)
V(comm.graph)$color[which(V(comm.graph)%in%which(V(comm.graph)$color == 'orange') == FALSE)] = 'lightblue'
V(comm.graph)$size[which(V(comm.graph)%in%which(V(comm.graph)$size >= 1) == FALSE)] = 1
plot(comm.graph, vertex.label='')
```

You can also access the number of granules and their size

```{r}
gran.num <- length( V(comm.graph)$size[V(comm.graph)$size > 1] ) 
gran.sizes <- V(comm.graph)$size[V(comm.graph)$size > 1]

```