---
title: "Discrete Model"
author: "Alex Padron"
date: "June 1, 2017"
output: html_document
---

# An example of how to run the discrete granule model scripts

- The granule model is a function that takes a number of parameters. 
- The number of nodes (node_number) represents the number of mRNAs to begin with.
- SpaceMax will symmetrically define the space we'll use throughout the simulation.
- A randomly placed empty graph, g.
- Total_time starting at 1 in this case.
- final_time to stop simulation at.
- Movement of a node is set to the product of a velocity factor (set to 1) and a time component, set to 1e-2
- Edge formation between nodes is set to the product of a k_on (1e-2) and a time componenet, set to 1e-2
- The dissociation of two nodes together is set to the product of P.int.off (1e-5) and a time component, set to 1e-2


```{r}
# Load libraries
library(igraph)
library(reshape2)

# Load granule functions
load.functions <- list.files('~/granule-functions', full.names = TRUE)
for (i in 1:length(load.functions)){
  source(load.functions[i])
}

# This function needs to be compiled every time. This can be skipped if load.functions is run in the same session
source('~/granule-functions/layoutOverlapFinder_v.R')
source('~/granule-functions/matrixIndex.R')


set.seed(10)
#this starts a wall clock if that's important to you
start.time <- Sys.time()

#define number of mRNAs & symmetrical simulation space
node_number = 35
spaceMax = 15

#make random graph
g=graph.empty(node_number,directed = FALSE)

#color nodes 
V(g)$color = 'lightblue'

#time step 
t = 1e-2

#movement
vel = 1
sigma = vel*t

#edge formation reaction
k_on = 1e-1
sigma.kon = k_on*t
P.int.on <- sigma.kon

#edge breaking reaction
P.int.off = 1e-5
P.int.off <- P.int.off * t

#randomly lay out nodes 
layout.old = layoutGen(node_number, spaceMax)
names = 1:node_number
layout.old = layout.old[[1]][,1:2]

#see the initial empty graph
plot(g, layout = layout.old,
       rescale = F, axes=TRUE, xlim=c(0,spaceMax), ylim=c(0,spaceMax), asp = 0 )

#final simulation step
RunLength = 100

#make lists to capture informationa about mRNA population size, mRNP population size, granule population size. This also makes lists to capture the graph and layout of the graph at each time step to revisit later if needed (g_list & layout_list)
gran_pop = vector('list', RunLength)
mRNP_pop = vector("list", RunLength ) 
mRNA_pop = vector("list", RunLength ) 
layout_list = vector("list", RunLength ) 
g_list = vector("list", RunLength ) 


total_time = 1

```
- mRNAs are defined as edge-less nodes (light blue)
- mRNPs are defined as nodes with more than 1 node (orange)
- granules are defined as interacting densely connected regions of interacting mRNPs. This information if found by using the walktrap algorithm to find communities in the graph
- This starts the simulation after the above parameters have been set

```{r}
while(total_time <= RunLength){ 
  
  whatToDo <- sample(1:3, 1, prob = c(sigma, P.int.on, P.int.off) )
  
  if (whatToDo == 1){
    #moves nodes one at a time 
    layout.old = nodeMover10(layout.old, g, node_number, spaceMax)
   }
  
  if (whatToDo == 2){
    
    #this randomly adds edge 
    DegreeType <- sample(0:4, size = 1, 
                         prob = c(P.int.on/5,P.int.on/4, P.int.on/3, 
                                  P.int.on/2, P.int.on/1) )
    
    toBind.index <-  which(degree(g) == DegreeType)
    if ( !isEmpty(toBind.index) && DegreeType >= 0 ) {
      toBind <- sample( toBind.index, 1)
      mRNA <- sample(1:node_number, 1)
    
      x <- indexLookUp(mRNA, c('A', 'B', 'C', 'D'), layout.old)
      optionsToBind <- x[layoutOverlapFinder.m(layout.old, x) == 1,]
      optionsToBind <- `if`(isEmpty(optionsToBind), layout.old[mRNA, ], optionsToBind)
    
    if ( is.null( nrow(optionsToBind) ) ) {
      indexFound <- indexFinder(layout.old, optionsToBind)
      g = add.edges(g, c(mRNA, indexFound) )
      g = simplify(g, remove.loops = TRUE) } else { 
        # this matches position to index using Rcpp. Function needs to be compiled every time
        NodeOptions <- matrixIndex(optionsToBind, layout.old)
        NodeOptions <- NodeOptions[NodeOptions != 0]
        
        #this finds the degrees of the available mRNPs to bind to
        degreeTypesAvailable <- degree(g)[NodeOptions]
        
        # this preferentially selects higher degrees than lower degree nearby nodes to form
        degreeTypesAvailable.selected <- sample(degreeTypesAvailable, 1, 
               prob = c( mRNP_selector_prob(degreeTypesAvailable, P.int.on) ) )
        degreeTypesAvailable.indx <- sample(which(degreeTypesAvailable == degreeTypesAvailable.selected, arr.ind = TRUE), 1)
        
        NewEdgeNode <- NodeOptions[degreeTypesAvailable.indx]
        g = add.edges(g, c(mRNA, NewEdgeNode) )
        g = simplify(g, remove.loops = TRUE)
      }
    }
  }
    
     #this deletes an edge if its a neighbor BUT not found in findNearestMovers
    #g <- edgeRemoverSpace(g, layout.old )
    
  
  if (whatToDo == 3){
    #this randomly deletes edge 
    DegreeType <- sample(0:4, size = 1, 
                         prob = c(P.int.off/1,P.int.off/2, P.int.off/3, 
                                  P.int.off/4, P.int.off/5) )
    toDelete.index <- which(degree(g) == DegreeType)
    if ( !isEmpty(toDelete.index) && DegreeType > 0 ) {
      toDelete <- sample( toDelete.index, 1)
      g <- delete_edges(g, E(g)[ from(toDelete) ] )
    }
  }
  
  E(g)$color = 'black'
  
  V(g)$color[degree(g) >= 1] <- 'orange'
  V(g)$color[degree(g) < 1] <- 'lightblue'

  g <- edgeRemoverSpace(g, layout.old ) 
  
  #plot(g, layout = layout.old,
  #     rescale = F, axes=TRUE, xlim=c(0,spaceMax), ylim=c(0,spaceMax), asp = 0 )
  
  gran_pop[[total_time]] = walktrap.community(g)
  mRNP_pop[[total_time]] = which(degree(g) >= 1)
  names(mRNP_pop) <- 'mRNP'
  mRNA_pop[[total_time]] = which(degree(g) < 1)
  names(mRNA_pop) <- 'mRNA'
  layout_list[[total_time]] = layout.old
  g_list[[total_time]] <- g
  
  print(total_time)
  
  total_time = total_time + 1  

  } 

#print time taken to run 
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
```

- To find densely connected regions you can use the walktrap algorithm or something equivalent. I like walktrap because it works better for smaller communities than some of the other options available. It works by performing a random walk, and defines a densely connected region based on where it sends more time in.

```{r}

#this gets information from the output of the model to plot granules, mRNPs, mRNA numbers
Num.Community=list()
size.Community.mean=list()
size.Community.sd=list()

for (i in 1:RunLength) {
  names(gran_pop[[i]]$membership) <- 1:node_number
  gran.length <- length(table(gran_pop[[i]]$membership)[table(gran_pop[[i]]$membership) ])
  gran.members <- lapply(1:gran.length, function(x) as.numeric(names(gran_pop[[i]]$membership[gran_pop[[i]]$membership == x])))
  Num.Community[[i]] <- length(unlist(lapply(gran.members, length))[unlist(lapply(gran.members, length)) ])
  size.Community.mean[[i]] <- mean(unlist(lapply(gran.members,length)))
  size.Community.sd[[i]] <- sd(unlist(lapply(gran.members,length)))
  }


#prepare for plotting

val.gran <- c(node_number, unlist(Num.Community))
val.RNP <- (c(0,unlist(lapply(mRNP_pop, length))))
val.mRNA <- c(node_number,unlist(lapply(mRNA_pop, length)))
val.comm.size <- c(unlist(size.Community.mean))

par(pin=c(2,2), tcl=0.25, ps=9, family="Helvetica")
#plot number of communities over time
plot(val.gran,lwd=2, pch=19, col='magenta', 
     ylab=c('Number of Granules'), xlab=c('Timestep'), type='l', ylim=c(0, 500) )

par(pin=c(2,2), tcl=0.25, ps=9, family="Helvetica")
plot(val.comm.size, lwd=2, cex=0.3, pch=19, 
     ylab=c('Mean Granule Size'), xlab=c('Timestep'), type='l')

#plot mRNP over time
par(pin=c(2,2), tcl=0.25, ps=9, family="Helvetica")
plot(val.RNP, lwd=2, pch=19, col='blue', 
     ylab=c('Number of mRNPs'), xlab=c('Timestep'), type='l', ylim=c(0, node_number) )

#plot mRNAs over time
par(pin=c(2,2), tcl=0.25, ps=9, family="Helvetica")
plot(val.mRNA,lwd=2, pch=19, col='red', 
     ylab=c('Number of mRNAs'), xlab=c('Timestep'), type='l', ylim=c(0, node_number) )

```
